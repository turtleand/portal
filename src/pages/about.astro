---
import Layout from '../layouts/Layout.astro';
import { initI18n, makeCopyToken } from '../utils/i18n';

const { locale, dictionary, t } = initI18n(Astro);
const traits = dictionary.about.traits ?? [];
const traitDescriptions = dictionary.about.traitDescriptions ?? [];
const backLabel = makeCopyToken('about.backLabel', t);
const pageDescriptionCopy = makeCopyToken('about.pageDescription', t);
const traitPopoverCloseCopy = makeCopyToken('about.traitPopoverCloseLabel', t);
const traitItems = traits.map((trait: string, index: number) => ({
  key: `about.traits.${index}`,
  descriptionKey: `about.traitDescriptions.${index}`,
  label: trait,
  description: traitDescriptions[index] ?? '',
}));

const summary = makeCopyToken('about.summary', t);
const philosophy = makeCopyToken('about.philosophy', t);
const currentFocusTitle = makeCopyToken('about.currentFocusTitle', t);
const currentFocus: string[] = dictionary.about.currentFocus ?? [];
const buildingTitle = makeCopyToken('about.buildingTitle', t);
const buildingItems: { emoji: string; name: string; url: string; description: string }[] = dictionary.about.buildingItems ?? [];
const writingTitle = makeCopyToken('about.writingTitle', t);
const writingItems: { title: string; url: string }[] = dictionary.about.writingItems ?? [];
const valuesTitle = makeCopyToken('about.valuesTitle', t);
const connectTitle = makeCopyToken('about.connectTitle', t);
const connectCta = makeCopyToken('about.connectCta', t);
---
<Layout
  title={t('about.pageTitle')}
  description={pageDescriptionCopy.text}
  locale={locale}
  dictionary={dictionary}
>
  <section
    class="px-6 py-16 md:px-0 md:py-20"
    data-about-section
  >
    <div class="mx-auto flex max-w-3xl flex-col gap-10 text-left rounded-3xl border border-white/5 bg-deepBlue/80 p-8 shadow-glow/0 backdrop-blur"
      data-about-shell
    >
      <!-- Back arrow -->
      <a
        href="/"
        data-locale-link
        data-base-href="/"
        aria-label={backLabel.text}
        data-i18n-key={backLabel.key}
        data-i18n-attr="aria-label"
        class="inline-flex h-11 w-11 items-center justify-center rounded-full border border-white/10 text-lg text-muted transition-colors hover:text-offWhite focus-visible:text-offWhite focus-visible:outline-none"
      >
        <span aria-hidden="true">←</span>
        <span class="sr-only" data-i18n-key={backLabel.key}>{backLabel.text}</span>
      </a>

      <!-- Professional Summary -->
      <div class="space-y-4">
        <p class="text-lg font-semibold text-offWhite leading-relaxed" data-i18n-key={summary.key}>
          {summary.text}
        </p>
        <p class="text-base text-offWhite/70 leading-relaxed" data-i18n-key={philosophy.key}>
          {philosophy.text}
        </p>
      </div>

      <!-- Current Focus -->
      <div class="space-y-4">
        <h2 class="text-lg font-semibold text-offWhite" data-i18n-key={currentFocusTitle.key}>
          {currentFocusTitle.text}
        </h2>
        <ul class="grid grid-cols-1 sm:grid-cols-2 gap-3">
          {currentFocus.map((item: string, i: number) => (
            <li
              class="rounded-xl border border-white/10 bg-white/5 px-4 py-3 text-sm text-offWhite/80"
              data-i18n-key={`about.currentFocus.${i}`}
            >
              {item}
            </li>
          ))}
        </ul>
      </div>

      <!-- What I'm Building -->
      <div class="space-y-4">
        <h2 class="text-lg font-semibold text-offWhite" data-i18n-key={buildingTitle.key}>
          {buildingTitle.text}
        </h2>
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
          {buildingItems.map((item: { emoji: string; name: string; url: string; description: string }, i: number) => {
            const inner = (
              <div class="flex flex-col gap-1">
                <span class="font-semibold text-offWhite">
                  <span>{item.emoji}</span>{' '}
                  <span data-i18n-key={`about.buildingItems.${i}.name`}>{item.name}</span>
                </span>
                <span class="text-sm text-offWhite/60" data-i18n-key={`about.buildingItems.${i}.description`}>
                  {item.description}
                </span>
              </div>
            );
            return item.url ? (
              <a
                href={item.url}
                target="_blank"
                rel="noopener noreferrer"
                class="rounded-xl border border-white/10 bg-white/5 px-4 py-3 transition-colors hover:border-white/20 hover:bg-white/10"
              >
                {inner}
              </a>
            ) : (
              <div class="rounded-xl border border-white/10 bg-white/5 px-4 py-3 opacity-60">
                {inner}
              </div>
            );
          })}
        </div>
      </div>

      <!-- Featured Writing -->
      <div class="space-y-4">
        <h2 class="text-lg font-semibold text-offWhite" data-i18n-key={writingTitle.key}>
          {writingTitle.text}
        </h2>
        <div class="flex flex-col gap-3">
          {writingItems.map((item: { title: string; url: string }, i: number) => (
            <a
              href={item.url}
              target="_blank"
              rel="noopener noreferrer"
              class="group flex items-center justify-between rounded-xl border border-white/10 bg-white/5 px-4 py-3 transition-colors hover:border-white/20 hover:bg-white/10"
            >
              <span class="text-offWhite/80 group-hover:text-offWhite transition-colors" data-i18n-key={`about.writingItems.${i}.title`}>
                {item.title}
              </span>
              <span class="text-offWhite/40 group-hover:text-offWhite/70 transition-colors" aria-hidden="true">→</span>
            </a>
          ))}
        </div>
      </div>

      <!-- Values & Character (existing traits) -->
      <div class="space-y-4">
        <h2 class="text-lg font-semibold text-offWhite" data-i18n-key={valuesTitle.key}>
          {valuesTitle.text}
        </h2>
        <ul
          class="space-y-4 text-base sm:space-y-5 md:text-lg"
          data-about-trait-list
        >
          {traitItems.map((trait) => (
            <li
              class="rounded-2xl border border-white/15 bg-white/10 px-4 py-4 text-offWhite shadow-[0_18px_45px_rgba(6,12,24,0.45)] backdrop-blur transition-colors sm:px-5 md:bg-white/5 md:shadow-none focus-within:border-white/30"
              data-trait-item
            >
              <button
                type="button"
                class="group flex w-full items-center justify-between gap-3 text-left font-semibold text-offWhite/90 transition-colors hover:text-offWhite focus-visible:text-offWhite focus-visible:outline-none"
                data-trait-trigger
                aria-expanded="false"
              >
                <span data-trait-label data-i18n-key={trait.key}>
                  {trait.label}
                </span>
                <span
                  aria-hidden="true"
                  class="text-lg text-offWhite/50 transition group-hover:text-offWhite"
                >
                  →
                </span>
              </button>
              <p
                class="mt-4 hidden border-t border-white/15 pt-4 text-base leading-relaxed text-offWhite/95 sm:text-sm sm:leading-relaxed sm:text-offWhite/85"
                data-trait-inline-description
                data-i18n-key={trait.descriptionKey}
              >
                {trait.description}
              </p>
            </li>
          ))}
        </ul>
        <span
          class="hidden"
          aria-hidden="true"
          data-trait-popover-close
          data-i18n-key={traitPopoverCloseCopy.key}
        >
          {traitPopoverCloseCopy.text}
        </span>
      </div>

      <!-- Connect -->
      <div class="space-y-4 border-t border-white/10 pt-8">
        <h2 class="text-lg font-semibold text-offWhite" data-i18n-key={connectTitle.key}>
          {connectTitle.text}
        </h2>
        <p class="text-base text-offWhite/70 leading-relaxed" data-i18n-key={connectCta.key}>
          {connectCta.text}
        </p>
        <div class="flex flex-wrap gap-4">
          <a
            href="https://github.com/turtlean"
            target="_blank"
            rel="noopener noreferrer"
            class="inline-flex items-center gap-2 rounded-full border border-white/10 px-4 py-2 text-sm text-offWhite/80 transition-colors hover:border-white/20 hover:text-offWhite"
          >
            GitHub
          </a>
          <a
            href="mailto:hello@turtleand.com"
            class="inline-flex items-center gap-2 rounded-full border border-white/10 px-4 py-2 text-sm text-offWhite/80 transition-colors hover:border-white/20 hover:text-offWhite"
          >
            Email
          </a>
          <a
            href="https://x.com/turtleand_world"
            target="_blank"
            rel="noopener noreferrer"
            class="inline-flex items-center gap-2 rounded-full border border-white/10 px-4 py-2 text-sm text-offWhite/80 transition-colors hover:border-white/20 hover:text-offWhite"
          >
            X / Twitter
          </a>
        </div>
      </div>
    </div>
  </section>
  <script is:inline>
    if (typeof window !== "undefined") {
      window.addEventListener("DOMContentLoaded", () => {
        const section = document.querySelector("[data-about-section]");
        const shell = document.querySelector("[data-about-shell]");

        if (!section || !shell) return;

        section.addEventListener("click", (event) => {
          const target = event.target;
          if (!(target instanceof Node)) return;
          if (!shell.contains(target)) {
            window.location.href = "/";
          }
        });

        const traitList = document.querySelector("[data-about-trait-list]");
        if (!traitList) return;

        const closeLabelSource = document.querySelector("[data-trait-popover-close]");
        const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)");
        const smallScreenQuery = window.matchMedia("(max-width: 768px)");
        const shouldUseInlineMode = () => prefersReducedMotion.matches || smallScreenQuery.matches;
        let useInlineMode = shouldUseInlineMode();
        /** @type {HTMLElement | null} */
        let activeItem = null;
        let hideTimeout = 0;
        /** @type {HTMLElement | null} */
        let lastFocusedElement = null;

        const setActiveTraitItem = (next) => {
          if (activeItem && activeItem !== next) {
            activeItem.removeAttribute("data-active-trait");
          }
          activeItem = next;
          if (activeItem) {
            activeItem.setAttribute("data-active-trait", "true");
          }
        };

        const popover = document.createElement("div");
        popover.dataset.traitPopover = "true";
        popover.setAttribute("role", "dialog");
        popover.setAttribute("aria-modal", "false");
        popover.className =
          "pointer-events-auto absolute z-40 max-w-sm rounded-2xl border border-white/20 bg-deepBlue p-5 text-offWhite shadow-glow/40 ring-1 ring-white/10 backdrop-blur-md transition duration-150 ease-out";
        popover.style.opacity = "0";
        popover.style.transform = "translateY(8px)";
        popover.hidden = true;

        const popoverTitle = document.createElement("p");
        popoverTitle.id = "about-trait-popover-title";
        popoverTitle.className = "text-base font-semibold text-offWhite";
        popover.appendChild(popoverTitle);

        const popoverDescription = document.createElement("p");
        popoverDescription.className = "mt-2 text-sm text-offWhite/90 leading-relaxed";
        popover.appendChild(popoverDescription);

        const closeButton = document.createElement("button");
        closeButton.type = "button";
        closeButton.className =
          "mt-4 inline-flex items-center justify-center rounded-full border border-white/20 px-4 py-1.5 text-sm text-offWhite/80 transition hover:text-offWhite focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-white/50";
        popover.appendChild(closeButton);

        popover.setAttribute("aria-labelledby", popoverTitle.id);
        popover.addEventListener("keydown", (event) => {
          if (event.key === "Tab") {
            event.preventDefault();
            closeButton.focus();
          }
        });

        document.body.appendChild(popover);

        const readCloseLabel = () => closeLabelSource?.textContent?.trim() || "Close";
        const updateCloseButtonLabel = () => {
          closeButton.textContent = readCloseLabel();
        };

        const getTrigger = (item) =>
          /** @type {HTMLButtonElement | null} */ (item.querySelector("[data-trait-trigger]"));
        const getDescriptionNode = (item) =>
          /** @type {HTMLElement | null} */ (item.querySelector("[data-trait-inline-description]"));

        const updatePopoverContent = (item) => {
          const trigger = getTrigger(item);
          const descriptionNode = getDescriptionNode(item);
          if (!trigger || !descriptionNode) return;
          const labelNode = /** @type {HTMLElement | null} */ (
            trigger.querySelector("[data-trait-label]")
          );
          const title = (labelNode ?? trigger).textContent?.trim() || "";
          const description = descriptionNode.textContent?.trim() || "";
          popoverTitle.textContent = title;
          popoverDescription.textContent = description;
        };

        const positionPopover = (trigger) => {
          if (!trigger) return;
          const rect = trigger.getBoundingClientRect();
          const scrollX = window.scrollX || window.pageXOffset;
          const scrollY = window.scrollY || window.pageYOffset;
          const spacing = 18;
          const viewportWidth = document.documentElement.clientWidth;
          const viewportHeight = document.documentElement.clientHeight;

          popover.style.left = "0px";
          popover.style.top = "0px";
          const { offsetWidth, offsetHeight } = popover;

          const centerOffset = rect.top + rect.height / 2 - offsetHeight / 2;
          const fitsRight = rect.right + spacing + offsetWidth <= scrollX + viewportWidth - 16;
          const fitsLeft = rect.left - spacing - offsetWidth >= scrollX + 16;
          let left;
          let top;

          if (fitsRight) {
            left = rect.right + spacing + scrollX;
            top = centerOffset + scrollY;
          } else if (fitsLeft) {
            left = rect.left - spacing - offsetWidth + scrollX;
            top = centerOffset + scrollY;
          } else {
            left = Math.max(
              scrollX + 16,
              Math.min(rect.left + scrollX, scrollX + viewportWidth - offsetWidth - 16),
            );
            top = rect.bottom + spacing + scrollY;
            if (top + offsetHeight > scrollY + viewportHeight - 16 && rect.top > offsetHeight + spacing) {
              top = rect.top + scrollY - offsetHeight - spacing;
            }
          }

          top = Math.max(scrollY + 16, Math.min(top, scrollY + viewportHeight - offsetHeight - 16));

          popover.style.left = `${left}px`;
          popover.style.top = `${top}px`;
        };

        updateCloseButtonLabel();

        const localeStore = window.turtleandLocaleStore;
        if (localeStore?.subscribe) {
          localeStore.subscribe(() => {
            updateCloseButtonLabel();
            if (activeItem && !popover.hidden && !useInlineMode) {
              updatePopoverContent(activeItem);
              positionPopover(getTrigger(activeItem));
            }
          });
        }

        const collapseInlineDescriptions = () => {
          const inlineNodes = traitList.querySelectorAll("[data-trait-inline-description]");
          inlineNodes.forEach((node) => node.classList.add("hidden"));
          const triggers = traitList.querySelectorAll("[data-trait-trigger]");
          triggers.forEach((button) => button.setAttribute("aria-expanded", "false"));
          setActiveTraitItem(null);
        };

        const closePopover = ({ returnFocus = true } = {}) => {
          if (popover.hidden) return;
          popover.style.opacity = "0";
          popover.style.transform = "translateY(6px)";
          const previous = activeItem;
          setActiveTraitItem(null);
          if (previous) {
            const previousTrigger = getTrigger(previous);
            previousTrigger?.setAttribute("aria-expanded", "false");
          }
          hideTimeout = window.setTimeout(() => {
            popover.hidden = true;
          }, 180);
          if (returnFocus && lastFocusedElement) {
            lastFocusedElement.focus();
          }
        };

        closeButton.addEventListener("click", () => closePopover());

        const openInlineForItem = (item) => {
          const descriptionNode = getDescriptionNode(item);
          const trigger = getTrigger(item);
          if (!descriptionNode || !trigger) return;
          const isVisible = !descriptionNode.classList.contains("hidden");
          collapseInlineDescriptions();
          if (!isVisible) {
            descriptionNode.classList.remove("hidden");
            trigger.setAttribute("aria-expanded", "true");
            setActiveTraitItem(item);
          }
        };

        const openPopoverForItem = (item, { focusPopover = true } = {}) => {
          const trigger = getTrigger(item);
          const descriptionNode = getDescriptionNode(item);
          if (!trigger || !descriptionNode) return;
          if (hideTimeout) {
            window.clearTimeout(hideTimeout);
          }
          setActiveTraitItem(item);
          updatePopoverContent(item);
          popover.hidden = false;
          popover.style.opacity = "0";
          popover.style.transform = "translateY(8px)";
          positionPopover(trigger);
          requestAnimationFrame(() => {
            popover.style.opacity = "1";
            popover.style.transform = "translateY(0)";
          });
          if (focusPopover) {
            lastFocusedElement =
              document.activeElement instanceof HTMLElement ? document.activeElement : null;
            closeButton.focus();
          } else {
            lastFocusedElement = null;
          }
          trigger.setAttribute("aria-expanded", "true");
        };

        const handleTriggerClick = (event) => {
          const currentTarget = event.currentTarget;
          if (!(currentTarget instanceof HTMLElement)) return;
          const item = currentTarget.closest("[data-trait-item]");
          if (!(item instanceof HTMLElement)) return;
          if (useInlineMode) {
            openInlineForItem(item);
            return;
          }
          if (activeItem === item && !popover.hidden) {
            closePopover();
            return;
          }
          collapseInlineDescriptions();
          closePopover({ returnFocus: false });
          openPopoverForItem(item);
        };

        const handlePointerDown = (event) => {
          if (popover.hidden) return;
          const target = event.target;
          if (!(target instanceof Node)) return;
          if (!popover.contains(target) && (!activeItem || !activeItem.contains(target))) {
            closePopover({ returnFocus: false });
          }
        };

        const handleKeydown = (event) => {
          if (event.key === "Escape") {
            if (!popover.hidden) {
              closePopover();
            } else {
              collapseInlineDescriptions();
            }
          }
        };

        const handleInteractionModeChange = () => {
          const nextInlineState = shouldUseInlineMode();
          if (useInlineMode === nextInlineState) return;
          const current = activeItem;
          useInlineMode = nextInlineState;
          if (useInlineMode) {
            const target = current;
            closePopover({ returnFocus: false });
            if (target) {
              openInlineForItem(target);
            }
          } else {
            collapseInlineDescriptions();
            if (current) {
              openPopoverForItem(current, { focusPopover: false });
            }
          }
        };

        traitList.querySelectorAll("[data-trait-trigger]").forEach((button) => {
          button.addEventListener("click", handleTriggerClick);
        });

        document.addEventListener("pointerdown", handlePointerDown);
        document.addEventListener("keydown", handleKeydown);

        if (typeof prefersReducedMotion.addEventListener === "function") {
          prefersReducedMotion.addEventListener("change", handleInteractionModeChange);
        } else if (typeof prefersReducedMotion.addListener === "function") {
          prefersReducedMotion.addListener(handleInteractionModeChange);
        }
        if (typeof smallScreenQuery.addEventListener === "function") {
          smallScreenQuery.addEventListener("change", handleInteractionModeChange);
        } else if (typeof smallScreenQuery.addListener === "function") {
          smallScreenQuery.addListener(handleInteractionModeChange);
        }
      });
    }
  </script>
  <style>
    :global([data-trait-item][data-active-trait='true']) {
      border-color: rgba(255, 255, 255, 0.45);
      background: rgba(255, 255, 255, 0.08);
      box-shadow: 0 25px 60px rgba(9, 17, 31, 0.35);
    }
    :global([data-trait-item][data-active-trait='true'] [data-trait-trigger]) {
      color: rgba(255, 255, 255, 0.98);
    }
    :global([data-trait-item][data-active-trait='true'] [data-trait-trigger] span:last-child) {
      color: rgba(255, 255, 255, 0.9);
    }
  </style>
</Layout>
